<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Depression Screening (demo)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial,sans-serif;margin:20px}
    .q{font-size:18px;margin:10px 0}
    button{padding:10px 16px;border-radius:10px;border:1px solid #ddd;cursor:pointer}
    #log{white-space:pre-wrap;background:#fafafa;border:1px solid #eee;padding:10px;border-radius:8px;margin-top:12px;height:160px;overflow:auto}
    video{width:480px;border-radius:12px;border:1px solid #eee}
  </style>
</head>
<body>
  <h2>üé•üé§ Depression Screening (demo)</h2>
  <p>We‚Äôll ask <b><span id="nq"></span></b> short questions. When you hit <b>Record</b>, we capture <b><span id="secs"></span>s</b> of webcam + mic, upload, extract features, and move on.</p>

  <div class="q"><b>Question <span id="qnum">1</span>:</b> <span id="qtext"></span></div>

  <video id="preview" autoplay muted playsinline></video><br/><br/>
  <button id="btn">Record <span id="btnsecs"></span>s</button>
  <button id="skip">Skip</button>
  <button id="retry" style="display:none">Retry</button>

  <div id="log"></div>

  <script>
    // Prefer direct Render on Vercel to avoid the 30s proxy timeout on large uploads
    // You can override with: window.API_BASE = 'https://<your-render-service>.onrender.com'
    const defaultApiBase = (location.hostname.endsWith('.vercel.app'))
      ? 'https://multimodal-depression-analysis-1.onrender.com'
      : 'https://multimodal-depression-analysis-1.onrender.com';
    const API_BASE = (window.API_BASE || defaultApiBase);
    // Same constants your Flask template used
    const QUESTIONS = [
      "hi i'm ellie thanks for coming in today",
      "i was created to talk to people in a safe and secure environment",
      "think of me as a friend i don't judge i can't i'm a computer",
      "i'm here to learn about people and would love to learn about you",
      "i'll ask a few questions to get us started and please feel free to tell me anything",
      "how are you doing today",
      "that's good",
      "where are you from originally"
    ];
    const SEC = 5;

    document.getElementById('nq').textContent = QUESTIONS.length;
    document.getElementById('secs').textContent = SEC;
    document.getElementById('btnsecs').textContent = SEC;

    const SID = (crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
    let idx = 0, mediaStream=null, busy=false;

    const qnum = document.getElementById('qnum');
    const qtext = document.getElementById('qtext');
  const btn = document.getElementById('btn');
  const skip = document.getElementById('skip');
  const retry = document.getElementById('retry');
    const log = document.getElementById('log');
    const preview = document.getElementById('preview');

    function setQ() {
      qnum.textContent = (idx+1);
      qtext.textContent = QUESTIONS[idx];
    }
    setQ();

    async function getStream(){
      if (!mediaStream) {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video:{ width:{ideal:320}, height:{ideal:240}, frameRate:{ideal:15, max:15} },
          audio:true
        });
        preview.srcObject = mediaStream;
      }
      return mediaStream;
    }

    function append(msg){ log.textContent += msg + "\n"; log.scrollTop = log.scrollHeight; }

    // Warm up backend (Render cold starts can take >30s)
    (async function warmup(){
      try {
        const res = await fetch(`${API_BASE}/health`, { method: 'GET' });
        const h = await res.json().catch(()=>({}));
        const of = h && h.openface_present ? 'yes' : 'no';
        const stt = h && h.stt_skip===false ? 'enabled' : 'disabled';
        const emb = h && h.hf_embeddings ? 'enabled' : 'disabled';
        append(`‚öôÔ∏è Backend warmed. OpenFace: ${of} ‚Ä¢ STT: ${stt} ‚Ä¢ Embeddings: ${emb}`);
      } catch {
        append('‚öôÔ∏è Backend warmed.');
      }
    })();

    async function recordOnce(){
      if (busy) return;
      busy = true; btn.disabled = true; skip.disabled = true;
      retry.style.display = 'none';

      try {
        const stream = await getStream();
        // Lower bitrate to shrink upload size and speed up processing on free tier
        const rec = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp8,opus',
          bitsPerSecond: 200000,            // ~200 kbps total (smaller upload)
          videoBitsPerSecond: 150000,       // ~150 kbps video
          audioBitsPerSecond: 64000         // ~64 kbps audio
        });
        let chunks = [];
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
        rec.start();
        append("üéôÔ∏è Recording...");
        await new Promise(r => setTimeout(r, SEC*1000));
        rec.stop();
        await new Promise(r => rec.onstop = r);
        const blob = new Blob(chunks, {type: 'video/webm'});
        append("‚¨ÜÔ∏è Uploading " + Math.round(blob.size/1024) + " KB");
        const fd = new FormData();
        fd.append('sid', SID);
        fd.append('qidx', idx);
        fd.append('file', blob, 'seg.webm');

        // Unified upload with robust fallback
        // Each attempt gets its own AbortController so a timeout on primary
        // doesn't poison the fallback attempt.
        const tryUpload = async (base, timeoutMs=180000) => {
          const ctrl = new AbortController();
          const timer = setTimeout(() => ctrl.abort(), timeoutMs);
          try {
            const res = await fetch(`${base}/segment`, {
              method:'POST', body:fd, signal: ctrl.signal,
              mode:'cors', cache:'no-store', credentials:'omit'
            });
            const j = await res.json().catch(() => ({}));
            return { ok: res.ok && j && j.ok, status: res.status, body: j };
          } finally {
            clearTimeout(timer);
          }
        };

        let ok = false; let status = 0; let firstErr = '';
  const primary = API_BASE;
  // If primary is direct Render, fallback to /api (Vercel proxy). If primary is /api, fallback to direct Render.
  const fallback = primary.startsWith('http') ? '/api' : 'https://multimodal-depression-analysis-1.onrender.com';
        try {
          const r1 = await tryUpload(primary, 180000);
          status = r1.status; ok = r1.ok;
          if (!ok) {
            append(`‚ùå Segment failed via primary (${primary}) status=${status||''}.`);
            append(`‚Ü™Ô∏è Retrying via fallback (${fallback})...`);
            const r2 = await tryUpload(fallback, 180000);
            ok = r2.ok; status = r2.status;
            if (ok) append(`‚úÖ Segment saved via fallback (${r2.body.count}/${QUESTIONS.length})`);
          } else {
            append(`‚úÖ Segment saved (${r1.body.count}/${QUESTIONS.length})`);
          }
        } catch (err) {
          const name = err?.name || '';
          const msg  = err?.message || String(err);
          firstErr = `${name}${msg? (': '+msg):''}`;
          append(`‚ö†Ô∏è Primary upload threw ${firstErr}. Retrying via fallback (${fallback})...`);
          try {
            const r2 = await tryUpload(fallback, 180000);
            ok = r2.ok; status = r2.status;
            if (ok) append(`‚úÖ Segment saved via fallback (${r2.body.count}/${QUESTIONS.length})`);
          } catch (err2) {
            const name2 = err2?.name || '';
            const msg2  = err2?.message || String(err2);
            append(`‚ùå Fallback upload also failed: ${name2}${msg2? (': '+msg2):''}`);
          }
        }
        if (!ok) {
          append(`‚ùå Segment failed (status=${status||''}). Please retry or skip.`);
          retry.style.display = 'inline-block';
          btn.disabled = false; skip.disabled = false;
        }
        if (ok) {
          idx++;
          if (idx < QUESTIONS.length) { setQ(); }
          else { finalize(); }
        }
      } finally {
        busy = false; btn.disabled = false; skip.disabled = false;
      }
    }

    async function finalize(){
      append("üß† Finalizing prediction...");
  const res = await fetch(`${API_BASE}/finalize?sid=` + SID);
      const j = await res.json().catch(()=>({}));
      if (!res.ok || !j) { append("‚ùå Finalize failed."); return; }
      append("üéØ P(Depressed)=" + j.p_depressed.toFixed(3) + " ‚Üí " + j.label);
    }

  btn.onclick = recordOnce;
  retry.onclick = () => { if (!busy) recordOnce(); };
    skip.onclick = () => { if (!busy) { idx++; if (idx<QUESTIONS.length) setQ(); else finalize(); } };
  </script>
</body>
</html>
